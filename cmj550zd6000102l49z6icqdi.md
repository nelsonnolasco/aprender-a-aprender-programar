---
title: "Estruturas de Dados e Funções:"
seoTitle: "Vetores, Strings e Funções: Uma Análise Behaviorista Radical"
seoDescription: "Vetores como cadeias de estímulos, funções como unidades comportamentais. Uma análise skinneriana da programação com exemplos práticos em Java e Python."
datePublished: Sun Dec 14 2025 03:00:49 GMT+0000 (Coordinated Universal Time)
cuid: cmj550zd6000102l49z6icqdi
slug: estruturas-de-dados-e-funcoes
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1765629386454/3e1169d1-55ab-4103-a038-213df0643607.png
tags: programacao-java-python-estruturasdedados-vetores-strings-funcoes-recursao-analisedocomportamento-behaviorismoradical-skinner-psicologia-engenhariadesoftware

---

Introdução

As estruturas de dados e funções constituem elementos fundamentais na programação, tradicionalmente apresentados mediante metáforas cognitivistas — vetores como "caixas de memória", funções como "processadores de informação" e recursão como "pensamento autorreferente". Contudo, uma análise sob a perspectiva do Behaviorismo Radical permite compreender esses conceitos enquanto relações funcionais entre comportamento e ambiente, dispensando constructos mentalistas.

O presente artigo propõe uma interpretação analítico-comportamental de vetores, strings, matrizes, funções e funções recursivas, demonstrando como essas estruturas podem ser compreendidas através de conceitos como cadeias comportamentais, controle de estímulos, comportamento governado por regras e contingências de reforçamento. Os exemplos em Java e Python ilustram cada conceito, facilitando a aquisição desses repertórios comportamentais pelo programador iniciante.

---

## Vetores (Arrays): Cadeias de Estímulos sob Controle Discriminativo

### A Análise Comportamental

Um **vetor** pode ser interpretado como uma **cadeia de estímulos organizados sequencialmente**, onde cada elemento ocupa uma posição específica acessível mediante um índice. Na perspectiva behaviorista, o índice funciona como **estímulo discriminativo (SD)** que ocasiona o acesso a um elemento particular da cadeia.

O conceito de **cadeia comportamental** oferece um paralelo adequado: assim como em uma cadeia cada resposta produz o estímulo discriminativo para a resposta subsequente, em um vetor cada índice discrimina univocamente o elemento correspondente. A organização sequencial do vetor estabelece uma **contingência de três termos** para cada acesso: o índice (SD) ocasiona a operação de acesso (R), que produz o valor armazenado (SR).

Adicionalmente, a **iteração** sobre vetores pode ser compreendida como a emissão repetida de uma classe de respostas (acesso ao elemento) sob controle de estímulos discriminativos sucessivos (índices incrementais), caracterizando um **comportamento repetitivo mantido por contingências programadas**.

### Exemplo em Java

```java
public class VetorComoEstimulos {
    public static void main(String[] args) {
        // Vetor: cadeia de estímulos discriminativos organizados
        String[] esquemasDereforco = {
            "CRF - Reforço Contínuo",
            "FR - Razão Fixa",
            "VR - Razão Variável",
            "FI - Intervalo Fixo",
            "VI - Intervalo Variável"
        };

        // Acesso direto: índice como SD para elemento específico
        System.out.println("=== Acesso Discriminado por Índice ===");
        int indiceAlvo = 2;  // SD
        String elementoAcessado = esquemasDereforco[indiceAlvo];  // R -> SR
        System.out.println("SD (índice): " + indiceAlvo);
        System.out.println("SR (elemento): " + elementoAcessado);

        System.out.println("\n=== Cadeia Comportamental: Iteração ===");
        // Iteração: emissão repetida sob controle de SDs sucessivos
        for (int i = 0; i < esquemasDereforco.length; i++) {
            System.out.println("SD[" + i + "] -> R(acesso) -> SR: " + esquemasDereforco[i]);
        }

        // Demonstração: busca como discriminação condicional
        System.out.println("\n=== Discriminação Condicional: Busca ===");
        String criterio = "Variável";
        for (int i = 0; i < esquemasDereforco.length; i++) {
            if (esquemasDereforco[i].contains(criterio)) {
                System.out.println("Elemento discriminado pelo critério '" + criterio + "': " 
                    + esquemasDereforco[i] + " (índice " + i + ")");
            }
        }
    }
}
```

### Exemplo em Python

```python
def demonstrar_vetor_como_cadeia_de_estimulos():
    # Vetor (lista): cadeia de estímulos discriminativos organizados
    esquemas_de_reforco: list[str] = [
        "CRF - Reforço Contínuo",
        "FR - Razão Fixa",
        "VR - Razão Variável",
        "FI - Intervalo Fixo",
        "VI - Intervalo Variável"
    ]

    # Acesso direto: índice como SD para elemento específico
    print("=== Acesso Discriminado por Índice ===")
    indice_alvo = 2  # SD
    elemento_acessado = esquemas_de_reforco[indice_alvo]  # R -> SR
    print(f"SD (índice): {indice_alvo}")
    print(f"SR (elemento): {elemento_acessado}")

    print("\n=== Cadeia Comportamental: Iteração ===")
    # Iteração: emissão repetida sob controle de SDs sucessivos
    for i, esquema in enumerate(esquemas_de_reforco):
        print(f"SD[{i}] -> R(acesso) -> SR: {esquema}")

    # Demonstração: busca como discriminação condicional
    print("\n=== Discriminação Condicional: Busca ===")
    criterio = "Variável"
    for i, esquema in enumerate(esquemas_de_reforco):
        if criterio in esquema:
            print(f"Elemento discriminado pelo critério '{criterio}': {esquema} (índice {i})")


if __name__ == "__main__":
    demonstrar_vetor_como_cadeia_de_estimulos()
```

**Saída esperada:**

```plaintext
=== Acesso Discriminado por Índice ===
SD (índice): 2
SR (elemento): VR - Razão Variável

=== Cadeia Comportamental: Iteração ===
SD[0] -> R(acesso) -> SR: CRF - Reforço Contínuo
SD[1] -> R(acesso) -> SR: FR - Razão Fixa
SD[2] -> R(acesso) -> SR: VR - Razão Variável
SD[3] -> R(acesso) -> SR: FI - Intervalo Fixo
SD[4] -> R(acesso) -> SR: VI - Intervalo Variável

=== Discriminação Condicional: Busca ===
Elemento discriminado pelo critério 'Variável': VR - Razão Variável (índice 2)
Elemento discriminado pelo critério 'Variável': VI - Intervalo Variável (índice 4)
```

---

## Strings: Cadeias de Comportamento Verbal Textual

### A Análise Comportamental

Na taxonomia skinneriana do comportamento verbal, o **textual** constitui um operante verbal no qual estímulos verbais escritos controlam respostas vocais correspondentes. Uma **string**, nesta perspectiva, representa uma **cadeia de estímulos textuais** — sequência de caracteres que, enquanto produto do comportamento verbal de um falante, pode ocasionar comportamento verbal em um ouvinte/leitor.

A string pode ser analisada como o **produto permanente de comportamento verbal**, permitindo que contingências de reforçamento operem através do tempo e do espaço. Cada caractere constitui uma unidade mínima de controle de estímulos, e a concatenação de caracteres forma unidades funcionais maiores (palavras, sentenças) que exercem controle sobre o comportamento do leitor.

As operações sobre strings — concatenação, busca, substituição — podem ser interpretadas como **transformações de produtos verbais** que alteram suas propriedades de controle de estímulos. A manipulação de strings pelo programador constitui, assim, comportamento verbal que produz novos estímulos verbais com funções específicas.

### Exemplo em Java

```java
public class StringComoComportamentoVerbal {
    public static void main(String[] args) {
        // String: produto permanente de comportamento verbal
        String definicaoOperante = "Comportamento operante é aquele que opera sobre o ambiente";

        System.out.println("=== String como Estímulo Verbal Textual ===");
        System.out.println("Produto verbal: " + definicaoOperante);
        System.out.println("Extensão da cadeia (caracteres): " + definicaoOperante.length());

        // Análise da cadeia em unidades funcionais (palavras)
        System.out.println("\n=== Segmentação em Unidades Funcionais ===");
        String[] unidadesFuncionais = definicaoOperante.split(" ");
        System.out.println("Número de unidades verbais (palavras): " + unidadesFuncionais.length);

        for (int i = 0; i < unidadesFuncionais.length; i++) {
            System.out.println("Unidade[" + i + "]: \"" + unidadesFuncionais[i] + "\"");
        }

        // Concatenação: junção de produtos verbais
        System.out.println("\n=== Concatenação: Composição de Produtos Verbais ===");
        String partePrincipio = "Comportamento";
        String partePredicado = " é função de suas consequências";
        String producaoVerbalCompleta = partePrincipio + partePredicado;
        System.out.println("Produto verbal resultante: " + producaoVerbalCompleta);

        // Busca: discriminação de padrões textuais
        System.out.println("\n=== Discriminação de Padrões Textuais ===");
        String textoAnalise = "O reforço positivo aumenta a frequência do comportamento";
        String padraoAlvo = "reforço";

        if (textoAnalise.contains(padraoAlvo)) {
            int posicao = textoAnalise.indexOf(padraoAlvo);
            System.out.println("Padrão '" + padraoAlvo + "' discriminado na posição: " + posicao);
        }

        // Substituição: transformação do produto verbal
        System.out.println("\n=== Transformação do Produto Verbal ===");
        String original = "A punição suprime o comportamento";
        String modificado = original.replace("suprime", "reduz a frequência d");
        System.out.println("Original: " + original);
        System.out.println("Transformado: " + modificado);

        // Análise caractere por caractere: unidades mínimas de controle
        System.out.println("\n=== Unidades Mínimas de Controle (Caracteres) ===");
        String termo = "OPERANTE";
        System.out.print("Cadeia de estímulos textuais: ");
        for (int i = 0; i < termo.length(); i++) {
            System.out.print("[" + termo.charAt(i) + "]");
        }
        System.out.println();
    }
}
```

### Exemplo em Python

```python
def demonstrar_string_como_comportamento_verbal():
    # String: produto permanente de comportamento verbal
    definicao_operante = "Comportamento operante é aquele que opera sobre o ambiente"

    print("=== String como Estímulo Verbal Textual ===")
    print(f"Produto verbal: {definicao_operante}")
    print(f"Extensão da cadeia (caracteres): {len(definicao_operante)}")

    # Análise da cadeia em unidades funcionais (palavras)
    print("\n=== Segmentação em Unidades Funcionais ===")
    unidades_funcionais = definicao_operante.split(" ")
    print(f"Número de unidades verbais (palavras): {len(unidades_funcionais)}")

    for i, unidade in enumerate(unidades_funcionais):
        print(f'Unidade[{i}]: "{unidade}"')

    # Concatenação: junção de produtos verbais
    print("\n=== Concatenação: Composição de Produtos Verbais ===")
    parte_principio = "Comportamento"
    parte_predicado = " é função de suas consequências"
    producao_verbal_completa = parte_principio + parte_predicado
    print(f"Produto verbal resultante: {producao_verbal_completa}")

    # Busca: discriminação de padrões textuais
    print("\n=== Discriminação de Padrões Textuais ===")
    texto_analise = "O reforço positivo aumenta a frequência do comportamento"
    padrao_alvo = "reforço"

    if padrao_alvo in texto_analise:
        posicao = texto_analise.index(padrao_alvo)
        print(f"Padrão '{padrao_alvo}' discriminado na posição: {posicao}")

    # Substituição: transformação do produto verbal
    print("\n=== Transformação do Produto Verbal ===")
    original = "A punição suprime o comportamento"
    modificado = original.replace("suprime", "reduz a frequência d")
    print(f"Original: {original}")
    print(f"Transformado: {modificado}")

    # Análise caractere por caractere: unidades mínimas de controle
    print("\n=== Unidades Mínimas de Controle (Caracteres) ===")
    termo = "OPERANTE"
    print("Cadeia de estímulos textuais: ", end="")
    for char in termo:
        print(f"[{char}]", end="")
    print()

    # Formatação: modelagem do produto verbal
    print("\n=== Modelagem do Produto Verbal (Formatação) ===")
    template = "O {tipo} é um processo de {processo}"
    producao_modelada = template.format(
        tipo="reforço negativo",
        processo="fortalecimento por remoção de estímulo aversivo"
    )
    print(f"Produto modelado: {producao_modelada}")


if __name__ == "__main__":
    demonstrar_string_como_comportamento_verbal()
```

**Saída esperada:**

```plaintext
=== String como Estímulo Verbal Textual ===
Produto verbal: Comportamento operante é aquele que opera sobre o ambiente
Extensão da cadeia (caracteres): 57

=== Segmentação em Unidades Funcionais ===
Número de unidades verbais (palavras): 9
Unidade[0]: "Comportamento"
Unidade[1]: "operante"
Unidade[2]: "é"
...

=== Concatenação: Composição de Produtos Verbais ===
Produto verbal resultante: Comportamento é função de suas consequências

=== Discriminação de Padrões Textuais ===
Padrão 'reforço' discriminado na posição: 2

=== Transformação do Produto Verbal ===
Original: A punição suprime o comportamento
Transformado: A punição reduz a frequência do comportamento

=== Unidades Mínimas de Controle (Caracteres) ===
Cadeia de estímulos textuais: [O][P][E][R][A][N][T][E]
```

---

## Matrizes: Redes Bidimensionais de Controle de Estímulos

### A Análise Comportamental

Uma **matriz** estende o conceito de vetor para múltiplas dimensões, estabelecendo uma **rede de controle de estímulos** onde cada elemento é discriminado por múltiplos índices simultaneamente. Esta estrutura pode ser interpretada como um sistema de **discriminação condicional** complexo, no qual o acesso a um elemento específico requer controle por dois ou mais estímulos discriminativos coordenados (linha e coluna).

Na análise do comportamento, a **discriminação condicional** envolve situações em que a função de um estímulo (SD ou S-delta) depende de outro estímulo contextual. A matriz implementa precisamente esta lógica: o índice da coluna somente discrimina o elemento correto condicionalmente ao índice da linha, e vice-versa. Esta estrutura permite representar **contingências multidimensionais** e **relações entre variáveis**.

A matriz também pode ser compreendida como um **ambiente estruturado** que estabelece múltiplas contingências simultâneas, onde o comportamento de navegação (acesso aos elementos) está sob controle de coordenadas que especificam posições no espaço bidimensional de estímulos.

### Exemplo em Java

```java
public class MatrizComoRedeDeContingencias {
    public static void main(String[] args) {
        // Matriz: rede bidimensional de controle de estímulos
        // Representa: Respostas do sujeito em diferentes condições experimentais
        // Linhas: Sessões | Colunas: Tipos de resposta

        String[] sessoes = {"Linha de Base", "Intervenção", "Reversão", "Reintervenção"};
        String[] tiposResposta = {"Respostas Corretas", "Erros", "Omissões"};

        int[][] dadosExperimentais = {
            {15, 8, 2},   // Linha de Base
            {42, 3, 0},   // Intervenção
            {18, 7, 1},   // Reversão
            {45, 2, 0}    // Reintervenção
        };

        System.out.println("=== Matriz como Rede de Contingências Experimentais ===\n");

        // Exibição da matriz com discriminação por coordenadas
        System.out.print(String.format("%-20s", ""));
        for (String tipo : tiposResposta) {
            System.out.print(String.format("%-20s", tipo));
        }
        System.out.println("\n" + "-".repeat(80));

        for (int linha = 0; linha < dadosExperimentais.length; linha++) {
            System.out.print(String.format("%-20s", sessoes[linha]));
            for (int coluna = 0; coluna < dadosExperimentais[linha].length; coluna++) {
                System.out.print(String.format("%-20d", dadosExperimentais[linha][coluna]));
            }
            System.out.println();
        }

        // Discriminação condicional: acesso por coordenadas
        System.out.println("\n=== Discriminação Condicional por Coordenadas ===");
        int linhaAlvo = 1;  // SD1: Sessão de Intervenção
        int colunaAlvo = 0; // SD2: Respostas Corretas

        System.out.println("SD1 (linha): " + sessoes[linhaAlvo]);
        System.out.println("SD2 (coluna): " + tiposResposta[colunaAlvo]);
        System.out.println("Valor discriminado: " + dadosExperimentais[linhaAlvo][colunaAlvo]);

        // Análise de contingências: soma por condição
        System.out.println("\n=== Análise de Contingências: Total por Sessão ===");
        for (int linha = 0; linha < dadosExperimentais.length; linha++) {
            int totalSessao = 0;
            for (int coluna = 0; coluna < dadosExperimentais[linha].length; coluna++) {
                totalSessao += dadosExperimentais[linha][coluna];
            }
            System.out.println(sessoes[linha] + ": " + totalSessao + " respostas totais");
        }

        // Comparação entre condições (efeito da intervenção)
        System.out.println("\n=== Análise Funcional: Efeito da Intervenção ===");
        int respostasLinhaBase = dadosExperimentais[0][0];
        int respostasIntervencao = dadosExperimentais[1][0];
        int diferenca = respostasIntervencao - respostasLinhaBase;
        double percentualMudanca = ((double) diferenca / respostasLinhaBase) * 100;

        System.out.println("Respostas corretas na Linha de Base: " + respostasLinhaBase);
        System.out.println("Respostas corretas na Intervenção: " + respostasIntervencao);
        System.out.printf("Mudança: %+d (%.1f%%)\n", diferenca, percentualMudanca);
    }
}
```

### Exemplo em Python

```python
def demonstrar_matriz_como_rede_de_contingencias():
    # Matriz: rede bidimensional de controle de estímulos
    # Representa: Respostas do sujeito em diferentes condições experimentais
    # Linhas: Sessões | Colunas: Tipos de resposta

    sessoes = ["Linha de Base", "Intervenção", "Reversão", "Reintervenção"]
    tipos_resposta = ["Respostas Corretas", "Erros", "Omissões"]

    dados_experimentais = [
        [15, 8, 2],   # Linha de Base
        [42, 3, 0],   # Intervenção
        [18, 7, 1],   # Reversão
        [45, 2, 0]    # Reintervenção
    ]

    print("=== Matriz como Rede de Contingências Experimentais ===\n")

    # Exibição da matriz com discriminação por coordenadas
    cabecalho = f"{'':20}" + "".join(f"{tipo:20}" for tipo in tipos_resposta)
    print(cabecalho)
    print("-" * 80)

    for linha, sessao in enumerate(sessoes):
        valores = "".join(f"{dados_experimentais[linha][col]:<20}" 
                         for col in range(len(tipos_resposta)))
        print(f"{sessao:20}{valores}")

    # Discriminação condicional: acesso por coordenadas
    print("\n=== Discriminação Condicional por Coordenadas ===")
    linha_alvo = 1  # SD1: Sessão de Intervenção
    coluna_alvo = 0  # SD2: Respostas Corretas

    print(f"SD1 (linha): {sessoes[linha_alvo]}")
    print(f"SD2 (coluna): {tipos_resposta[coluna_alvo]}")
    print(f"Valor discriminado: {dados_experimentais[linha_alvo][coluna_alvo]}")

    # Análise de contingências: soma por condição
    print("\n=== Análise de Contingências: Total por Sessão ===")
    for linha, sessao in enumerate(sessoes):
        total_sessao = sum(dados_experimentais[linha])
        print(f"{sessao}: {total_sessao} respostas totais")

    # Comparação entre condições (efeito da intervenção)
    print("\n=== Análise Funcional: Efeito da Intervenção ===")
    respostas_linha_base = dados_experimentais[0][0]
    respostas_intervencao = dados_experimentais[1][0]
    diferenca = respostas_intervencao - respostas_linha_base
    percentual_mudanca = (diferenca / respostas_linha_base) * 100

    print(f"Respostas corretas na Linha de Base: {respostas_linha_base}")
    print(f"Respostas corretas na Intervenção: {respostas_intervencao}")
    print(f"Mudança: {diferenca:+d} ({percentual_mudanca:.1f}%)")

    # Matriz de contingências: representação de relações funcionais
    print("\n=== Matriz de Contingências Comportamentais ===")

    # Matriz representando relações SD-R-SR
    contingencias = [
        ["SD", "Resposta", "Consequência", "Efeito"],
        ["Luz acesa", "Pressão à barra", "Alimento", "R+"],
        ["Som 1000Hz", "Pressão à barra", "Nenhuma", "Extinção"],
        ["Luz vermelha", "Pressão à barra", "Choque", "P+"]
    ]

    for linha in contingencias:
        print(f"{linha[0]:15} | {linha[1]:18} | {linha[2]:15} | {linha[3]}")


if __name__ == "__main__":
    demonstrar_matriz_como_rede_de_contingencias()
```

**Saída esperada:**

```plaintext
=== Matriz como Rede de Contingências Experimentais ===

                    Respostas Corretas  Erros               Omissões            
--------------------------------------------------------------------------------
Linha de Base       15                  8                   2                   
Intervenção         42                  3                   0                   
Reversão            18                  7                   1                   
Reintervenção       45                  2                   0                   

=== Discriminação Condicional por Coordenadas ===
SD1 (linha): Intervenção
SD2 (coluna): Respostas Corretas
Valor discriminado: 42

=== Análise de Contingências: Total por Sessão ===
Linha de Base: 25 respostas totais
Intervenção: 45 respostas totais
Reversão: 26 respostas totais
Reintervenção: 47 respostas totais

=== Análise Funcional: Efeito da Intervenção ===
Respostas corretas na Linha de Base: 15
Respostas corretas na Intervenção: 42
Mudança: +27 (180.0%)
```

---

## Funções: Unidades Funcionais de Comportamento Encapsulado

### A Análise Comportamental

Uma **função** em programação pode ser interpretada como uma **unidade funcional de comportamento encapsulado** — um repertório comportamental delimitado que, quando evocado, produz consequências específicas. Os **parâmetros** funcionam como **estímulos discriminativos** que controlam a forma específica de execução, enquanto o **valor de retorno** constitui a **consequência** produzida pela emissão do comportamento.

Esta análise alinha-se com o conceito de **operante** como unidade de análise: assim como o operante é definido por sua função (relação com consequências) e não por sua topografia específica, uma função é definida pelo que realiza (sua funcionalidade) independentemente dos detalhes de implementação interna. A **assinatura da função** (nome, parâmetros, tipo de retorno) especifica as contingências sob as quais a unidade comportamental opera.

O **princípio da responsabilidade única** em programação encontra paralelo na especificação precisa de contingências: uma função bem projetada estabelece uma relação clara entre estímulos antecedentes (parâmetros), resposta (processamento) e consequência (retorno), facilitando a previsão e controle do comportamento do programa.

### Exemplo em Java

```java
public class FuncaoComoUnidadeComportamental {

    // Função: unidade comportamental que calcula taxa de resposta
    // Parâmetros (SDs): número de respostas e tempo
    // Retorno (SR): taxa calculada
    public static double calcularTaxaDeResposta(int numeroRespostas, double tempoMinutos) {
        if (tempoMinutos <= 0) {
            return 0.0;
        }
        return numeroRespostas / tempoMinutos;
    }

    // Função: classifica padrão de resposta baseado na taxa
    public static String classificarPadraoDeResposta(double taxa) {
        if (taxa < 5) {
            return "Baixa frequência - possível extinção ou saciação";
        } else if (taxa < 20) {
            return "Frequência moderada - manutenção estável";
        } else if (taxa < 50) {
            return "Alta frequência - forte controle por reforçamento";
        } else {
            return "Frequência muito alta - possível esquema de razão";
        }
    }

    // Função com múltiplas responsabilidades comportamentais
    public static void analisarSessaoExperimental(String sujeito, int respostas, 
                                                   double tempo, int reforcos) {
        System.out.println("=== Análise da Sessão Experimental ===");
        System.out.println("Sujeito: " + sujeito);
        System.out.println("Total de respostas: " + respostas);
        System.out.println("Duração (minutos): " + tempo);
        System.out.println("Reforços liberados: " + reforcos);

        // Chamada a outras unidades comportamentais
        double taxa = calcularTaxaDeResposta(respostas, tempo);
        System.out.printf("Taxa de resposta: %.2f R/min\n", taxa);

        String padrao = classificarPadraoDeResposta(taxa);
        System.out.println("Classificação: " + padrao);

        if (reforcos > 0) {
            double razaoMedia = (double) respostas / reforcos;
            System.out.printf("Razão média efetiva: %.1f respostas/reforço\n", razaoMedia);
        }
    }

    // Função pura: comportamento determinístico (mesmos SDs -> mesmo SR)
    public static int calcularIntervaloEntreReforcos(int intervaloBase, int variacao) {
        // Simula VI (Intervalo Variável)
        return intervaloBase + (int)(Math.random() * variacao * 2) - variacao;
    }

    public static void main(String[] args) {
        // Evocação das unidades comportamentais
        System.out.println("=== Função como Contingência de Três Termos ===\n");

        // SD (parâmetros) -> R (execução) -> SR (retorno)
        int respostasSessao = 180;
        double duracaoSessao = 15.0;

        System.out.println("SD1 (respostas): " + respostasSessao);
        System.out.println("SD2 (tempo): " + duracaoSessao + " min");

        double resultado = calcularTaxaDeResposta(respostasSessao, duracaoSessao);
        System.out.println("SR (taxa): " + resultado + " R/min\n");

        // Análise completa
        analisarSessaoExperimental("Rato-S1", respostasSessao, duracaoSessao, 36);

        System.out.println("\n=== Demonstração de Intervalo Variável ===");
        System.out.println("Intervalos gerados (VI-30 ±10):");
        for (int i = 1; i <= 5; i++) {
            int intervalo = calcularIntervaloEntreReforcos(30, 10);
            System.out.println("Reforço " + i + ": após " + intervalo + " segundos");
        }
    }
}
```

### Exemplo em Python

```python
from typing import Tuple
import random


# Função: unidade comportamental que calcula taxa de resposta
# Parâmetros (SDs): número de respostas e tempo
# Retorno (SR): taxa calculada
def calcular_taxa_de_resposta(numero_respostas: int, tempo_minutos: float) -> float:
    """Calcula a taxa de resposta por minuto."""
    if tempo_minutos <= 0:
        return 0.0
    return numero_respostas / tempo_minutos


# Função: classifica padrão de resposta baseado na taxa
def classificar_padrao_de_resposta(taxa: float) -> str:
    """Classifica o padrão comportamental com base na taxa de resposta."""
    if taxa < 5:
        return "Baixa frequência - possível extinção ou saciação"
    elif taxa < 20:
        return "Frequência moderada - manutenção estável"
    elif taxa < 50:
        return "Alta frequência - forte controle por reforçamento"
    else:
        return "Frequência muito alta - possível esquema de razão"


# Função que retorna múltiplos valores (tuple unpacking)
def analisar_desempenho(respostas: int, tempo: float, reforcos: int) -> Tuple[float, float, str]:
    """
    Analisa o desempenho e retorna múltiplas medidas.
    Demonstra função com múltiplas consequências (retornos).
    """
    taxa = calcular_taxa_de_resposta(respostas, tempo)
    razao_efetiva = respostas / reforcos if reforcos > 0 else 0
    classificacao = classificar_padrao_de_resposta(taxa)

    return taxa, razao_efetiva, classificacao


# Função com múltiplas responsabilidades comportamentais
def analisar_sessao_experimental(sujeito: str, respostas: int, 
                                  tempo: float, reforcos: int) -> None:
    """Realiza análise completa de uma sessão experimental."""
    print("=== Análise da Sessão Experimental ===")
    print(f"Sujeito: {sujeito}")
    print(f"Total de respostas: {respostas}")
    print(f"Duração (minutos): {tempo}")
    print(f"Reforços liberados: {reforcos}")

    # Chamada a outras unidades comportamentais
    taxa, razao, padrao = analisar_desempenho(respostas, tempo, reforcos)

    print(f"Taxa de resposta: {taxa:.2f} R/min")
    print(f"Classificação: {padrao}")

    if reforcos > 0:
        print(f"Razão média efetiva: {razao:.1f} respostas/reforço")


# Função geradora: produz sequência de consequências
def gerar_intervalos_variaveis(intervalo_base: int, variacao: int, quantidade: int):
    """
    Gera intervalos para esquema VI (Intervalo Variável).
    Função geradora - produz consequências sob demanda.
    """
    for _ in range(quantidade):
        yield intervalo_base + random.randint(-variacao, variacao)


# Função lambda: unidade comportamental mínima
calcular_irt = lambda tempo_atual, tempo_anterior: tempo_atual - tempo_anterior


def main():
    print("=== Função como Contingência de Três Termos ===\n")

    # SD (parâmetros) -> R (execução) -> SR (retorno)
    respostas_sessao = 180
    duracao_sessao = 15.0

    print(f"SD1 (respostas): {respostas_sessao}")
    print(f"SD2 (tempo): {duracao_sessao} min")

    resultado = calcular_taxa_de_resposta(respostas_sessao, duracao_sessao)
    print(f"SR (taxa): {resultado} R/min\n")

    # Análise completa
    analisar_sessao_experimental("Rato-S1", respostas_sessao, duracao_sessao, 36)

    print("\n=== Demonstração de Intervalo Variável ===")
    print("Intervalos gerados (VI-30 ±10):")
    for i, intervalo in enumerate(gerar_intervalos_variaveis(30, 10, 5), 1):
        print(f"Reforço {i}: após {intervalo} segundos")

    print("\n=== Função Lambda: IRT (Inter-Response Time) ===")
    tempos_resposta = [0, 2.3, 4.1, 5.8, 9.2, 10.5]
    print("Tempos de resposta:", tempos_resposta)
    print("IRTs calculados:", end=" ")
    for i in range(1, len(tempos_resposta)):
        irt = calcular_irt(tempos_resposta[i], tempos_resposta[i-1])
        print(f"{irt:.1f}s", end=" ")
    print()


if __name__ == "__main__":
    main()
```

**Saída esperada:**

```plaintext
=== Função como Contingência de Três Termos ===

SD1 (respostas): 180
SD2 (tempo): 15.0 min
SR (taxa): 12.0 R/min

=== Análise da Sessão Experimental ===
Sujeito: Rato-S1
Total de respostas: 180
Duração (minutos): 15.0
Reforços liberados: 36
Taxa de resposta: 12.00 R/min
Classificação: Frequência moderada - manutenção estável
Razão média efetiva: 5.0 respostas/reforço

=== Demonstração de Intervalo Variável ===
Intervalos gerados (VI-30 ±10):
Reforço 1: após 28 segundos
Reforço 2: após 35 segundos
...
```

---

## Funções Recursivas: Cadeias Comportamentais Autorreferentes

### A Análise Comportamental

A **recursão** constitui um caso particular de organização comportamental em que a emissão de uma resposta produz estímulos que ocasionam a emissão da mesma classe de respostas. Este padrão pode ser interpretado como uma **cadeia comportamental autorreferente**, onde cada elo da cadeia reinstala as condições que evocam a própria cadeia.

Na perspectiva behaviorista radical, a recursão relaciona-se com o **comportamento governado por regras**: a definição recursiva especifica uma regra que determina o comportamento em cada situação, incluindo uma **condição de parada** (caso base) que interrompe a cadeia quando determinado critério é satisfeito. Sem o caso base, a cadeia comportamental persistiria indefinidamente, análogo à **estereotipia comportamental** observada em certos contextos.

A recursão também pode ser compreendida através do conceito de **operações de estabelecimento condicionais**: cada chamada recursiva estabelece o contexto (parâmetros modificados) que dá função evocativa à próxima chamada, até que a condição de parada altere a contingência, produzindo a consequência final que se propaga retroativamente pela cadeia.

### Exemplo em Java

```java
public class RecursaoComoCadeiaAutorreferente {

    // Caso clássico: fatorial como cadeia comportamental autorreferente
    public static long calcularFatorial(int n) {
        // Caso base: condição de parada que interrompe a cadeia
        if (n <= 1) {
            System.out.println("  Caso base atingido: fatorial(1) = 1");
            return 1;
        }

        // Caso recursivo: resposta que evoca a mesma classe de respostas
        System.out.println("  Elo da cadeia: fatorial(" + n + ") = " + n + " × fatorial(" + n + "-1)");
        return n * calcularFatorial(n - 1);
    }

    // Recursão com contexto comportamental: Modelagem (Shaping)
    // Aproximações sucessivas ao comportamento alvo
    public static void simularModelagem(String comportamentoAtual, String comportamentoAlvo, 
                                         int proximidade, int criterio) {
        System.out.println("Aproximação atual: \"" + comportamentoAtual + "\" (proximidade: " 
                          + proximidade + "/" + criterio + ")");

        // Caso base: critério de modelagem atingido
        if (proximidade >= criterio) {
            System.out.println(">>> Comportamento alvo estabelecido: \"" + comportamentoAlvo + "\"");
            System.out.println(">>> Modelagem concluída com sucesso!");
            return;
        }

        // Reforçamento diferencial: aproximação sucessiva
        String novaAproximacao = refinarComportamento(comportamentoAtual, comportamentoAlvo);
        int novaProximidade = proximidade + 1;

        System.out.println("    [Reforçamento diferencial aplicado]");

        // Chamada recursiva: próximo elo na cadeia de modelagem
        simularModelagem(novaAproximacao, comportamentoAlvo, novaProximidade, criterio);
    }

    private static String refinarComportamento(String atual, String alvo) {
        // Simulação simplificada de aproximação
        int proximidade = Math.min(atual.length() + 2, alvo.length());
        return alvo.substring(0, proximidade);
    }

    // Recursão com ramificação: Fibonacci como contingências divergentes
    public static int fibonacci(int n, String identacao) {
        System.out.println(identacao + "fibonacci(" + n + ")");

        // Casos base
        if (n <= 0) return 0;
        if (n == 1) return 1;

        // Ramificação: duas cadeias comportamentais evocadas
        return fibonacci(n - 1, identacao + "  ") + fibonacci(n - 2, identacao + "  ");
    }

    // Recursão em estrutura: contagem de respostas em hierarquia
    public static int contarElementos(int[] vetor, int indice) {
        // Caso base: fim da estrutura
        if (indice >= vetor.length) {
            return 0;
        }

        // Soma elemento atual + contagem recursiva do restante
        return vetor[indice] + contarElementos(vetor, indice + 1);
    }

    public static void main(String[] args) {
        System.out.println("=== Recursão como Cadeia Comportamental Autorreferente ===\n");

        System.out.println("--- Fatorial: Cadeia Linear ---");
        int numero = 5;
        long resultado = calcularFatorial(numero);
        System.out.println("Resultado: " + numero + "! = " + resultado);

        System.out.println("\n--- Modelagem: Aproximações Sucessivas ---");
        simularModelagem("P", "Pressionar a barra", 1, 5);

        System.out.println("\n--- Fibonacci: Cadeias Divergentes (n=4) ---");
        int fib = fibonacci(4, "");
        System.out.println("Resultado: " + fib);

        System.out.println("\n--- Soma Recursiva: Dados de Sessão ---");
        int[] respostasPorMinuto = {12, 15, 18, 14, 16, 20};
        int totalRespostas = contarElementos(respostasPorMinuto, 0);
        System.out.println("Total de respostas na sessão: " + totalRespostas);
    }
}
```

### Exemplo em Python

```python
from typing import List, Dict, Any


# Caso clássico: fatorial como cadeia comportamental autorreferente
def calcular_fatorial(n: int, nivel: int = 0) -> int:
    """
    Calcula fatorial demonstrando a cadeia autorreferente.
    Cada chamada produz o SD para a próxima chamada.
    """
    identacao = "  " * nivel

    # Caso base: condição de parada que interrompe a cadeia
    if n <= 1:
        print(f"{identacao}Caso base atingido: fatorial(1) = 1")
        return 1

    # Caso recursivo: resposta que evoca a mesma classe de respostas
    print(f"{identacao}Elo da cadeia: fatorial({n}) = {n} × fatorial({n-1})")
    resultado = n * calcular_fatorial(n - 1, nivel + 1)
    print(f"{identacao}Retorno propagado: {resultado}")
    return resultado


# Recursão com contexto comportamental: Modelagem (Shaping)
def simular_modelagem(comportamento_atual: str, comportamento_alvo: str,
                       proximidade: int, criterio: int) -> None:
    """
    Simula o processo de modelagem por aproximações sucessivas.
    A recursão representa os passos do shaping.
    """
    print(f"Aproximação atual: \"{comportamento_atual}\" "
          f"(proximidade: {proximidade}/{criterio})")

    # Caso base: critério de modelagem atingido
    if proximidade >= criterio:
        print(f">>> Comportamento alvo estabelecido: \"{comportamento_alvo}\"")
        print(">>> Modelagem concluída com sucesso!")
        return

    # Reforçamento diferencial: aproximação sucessiva
    nova_aproximacao = comportamento_alvo[:min(len(comportamento_atual) + 3, 
                                                len(comportamento_alvo))]
    nova_proximidade = proximidade + 1

    print("    [Reforçamento diferencial aplicado]")

    # Chamada recursiva: próximo elo na cadeia de modelagem
    simular_modelagem(nova_aproximacao, comportamento_alvo, 
                      nova_proximidade, criterio)


# Recursão para análise de cadeias comportamentais
def analisar_cadeia_comportamental(cadeia: List[Dict[str, str]], 
                                    indice: int = 0) -> None:
    """
    Analisa recursivamente uma cadeia comportamental.
    Cada elo é SD para o próximo e SR do anterior.
    """
    # Caso base: fim da cadeia
    if indice >= len(cadeia):
        print("\n[Cadeia comportamental completada]")
        return

    elo = cadeia[indice]
    print(f"\nElo {indice + 1} da cadeia:")
    print(f"  SD: {elo['sd']}")
    print(f"  R:  {elo['resposta']}")
    print(f"  SR/SD+1: {elo['consequencia']}")

    # Chamada recursiva: próximo elo
    analisar_cadeia_comportamental(cadeia, indice + 1)


# Recursão com memorização: otimização comportamental
def fibonacci_memorizado(n: int, memoria: Dict[int, int] = None) -> int:
    """
    Fibonacci com memorização - análogo à aprendizagem:
    respostas previamente reforçadas são recuperadas sem
    necessidade de nova emissão completa.
    """
    if memoria is None:
        memoria = {}

    # Verifica se resposta já foi "aprendida" (memorizada)
    if n in memoria:
        return memoria[n]

    # Casos base
    if n <= 0:
        return 0
    if n == 1:
        return 1

    # Calcula e "aprende" (memoriza) o resultado
    resultado = fibonacci_memorizado(n - 1, memoria) + fibonacci_memorizado(n - 2, memoria)
    memoria[n] = resultado

    return resultado


# Recursão para processamento de estruturas hierárquicas
def processar_contingencias_aninhadas(estrutura: Dict[str, Any], 
                                       nivel: int = 0) -> None:
    """
    Processa recursivamente contingências organizadas hierarquicamente.
    Demonstra recursão em estruturas de dados complexas.
    """
    identacao = "  " * nivel

    for chave, valor in estrutura.items():
        if isinstance(valor, dict):
            print(f"{identacao}{chave}:")
            processar_contingencias_aninhadas(valor, nivel + 1)
        else:
            print(f"{identacao}{chave}: {valor}")


def main():
    print("=== Recursão como Cadeia Comportamental Autorreferente ===\n")

    print("--- Fatorial: Cadeia Linear com Propagação de Consequências ---")
    numero = 5
    resultado = calcular_fatorial(numero)
    print(f"\nResultado final: {numero}! = {resultado}")

    print("\n" + "="*60)
    print("\n--- Modelagem: Aproximações Sucessivas Recursivas ---")
    simular_modelagem("Pre", "Pressionar a barra", 1, 5)

    print("\n" + "="*60)
    print("\n--- Análise de Cadeia Comportamental ---")

    cadeia_escovar_dentes = [
        {"sd": "Horário noturno + desconforto bucal",
         "resposta": "Ir ao banheiro",
         "consequencia": "Visão da pia e escova"},
        {"sd": "Visão da pia e escova",
         "resposta": "Pegar escova e pasta",
         "consequencia": "Escova com pasta na mão"},
        {"sd": "Escova com pasta na mão",
         "resposta": "Escovar os dentes",
         "consequencia": "Sensação de limpeza"},
        {"sd": "Sensação de limpeza + espuma",
         "resposta": "Enxaguar a boca",
         "consequencia": "Boca limpa (SR+)"}
    ]

    analisar_cadeia_comportamental(cadeia_escovar_dentes)

    print("\n" + "="*60)
    print("\n--- Fibonacci Memorizado: Aprendizagem Otimizada ---")
    for i in range(10):
        print(f"F({i}) = {fibonacci_memorizado(i)}")

    print("\n" + "="*60)
    print("\n--- Processamento de Contingências Hierárquicas ---")

    contingencias_hierarquicas = {
        "Contexto Escolar": {
            "SD": "Professora faz pergunta",
            "Resposta": "Aluno levanta a mão",
            "Consequências": {
                "Reforço Positivo": "Elogio da professora",
                "Efeito": "Aumento da participação"
            }
        },
        "Contexto Clínico": {
            "SD": "Terapeuta apresenta estímulo",
            "Resposta": "Cliente emite tato",
            "Consequências": {
                "Reforço Social": "Validação do terapeuta",
                "Efeito": "Fortalecimento do repertório verbal"
            }
        }
    }

    processar_contingencias_aninhadas(contingencias_hierarquicas)


if __name__ == "__main__":
    main()
```

**Saída esperada:**

```plaintext
=== Recursão como Cadeia Comportamental Autorreferente ===

--- Fatorial: Cadeia Linear com Propagação de Consequências ---
Elo da cadeia: fatorial(5) = 5 × fatorial(4)
  Elo da cadeia: fatorial(4) = 4 × fatorial(3)
    Elo da cadeia: fatorial(3) = 3 × fatorial(2)
      Elo da cadeia: fatorial(2) = 2 × fatorial(1)
        Caso base atingido: fatorial(1) = 1
      Retorno propagado: 2
    Retorno propagado: 6
  Retorno propagado: 24
Retorno propagado: 120

Resultado final: 5! = 120

--- Modelagem: Aproximações Sucessivas Recursivas ---
Aproximação atual: "Pre" (proximidade: 1/5)
    [Reforçamento diferencial aplicado]
Aproximação atual: "Pressi" (proximidade: 2/5)
    [Reforçamento diferencial aplicado]
...
>>> Comportamento alvo estabelecido: "Pressionar a barra"
>>> Modelagem concluída com sucesso!

--- Análise de Cadeia Comportamental ---

Elo 1 da cadeia:
  SD: Horário noturno + desconforto bucal
  R:  Ir ao banheiro
  SR/SD+1: Visão da pia e escova
...
[Cadeia comportamental completada]
```

---

## Considerações Finais: Estruturas e Funções como Contingências Programadas

A análise behaviorista radical das estruturas de dados e funções revela que esses conceitos computacionais podem ser interpretados mediante princípios comportamentais estabelecidos empiricamente:

1. **Vetores** constituem cadeias de estímulos organizados sob controle discriminativo de índices, permitindo acesso sistemático a elementos específicos mediante contingências de três termos.
    
2. **Strings** representam produtos permanentes de comportamento verbal textual, cadeias de estímulos que podem ser segmentadas, transformadas e recombinadas, exercendo controle sobre o comportamento de leitores e processadores.
    
3. **Matrizes** estabelecem redes bidimensionais de controle de estímulos, implementando discriminação condicional onde múltiplos índices coordenam o acesso a elementos específicos.
    
4. **Funções** operam como unidades comportamentais encapsuladas, com parâmetros funcionando como estímulos discriminativos e valores de retorno como consequências produzidas pelo comportamento.
    
5. **Funções recursivas** constituem cadeias comportamentais autorreferentes, onde cada resposta reinstala as condições de evocação da mesma classe de respostas até que uma condição de parada altere a contingência.
    

Esta perspectiva oferece uma fundamentação alternativa para o ensino de programação, conectando conceitos abstratos a princípios de aprendizagem empiricamente estabelecidos. O programador, ao compreender estruturas e funções como sistemas de contingências, desenvolve repertório analítico que facilita tanto a compreensão quanto a produção de código eficiente e bem organizado.

A análise funcional do código — identificando antecedentes, respostas e consequências em cada estrutura — constitui ferramenta poderosa para depuração, otimização e comunicação técnica, demonstrando a aplicabilidade do Behaviorismo Radical como referencial interpretativo para fenômenos da computação.

---

## Referências

Catania, A. C. (1999). *Aprendizagem: Comportamento, linguagem e cognição* (4ª ed.). Artmed.

De Rose, J. C. (1993). Classes de estímulos: implicações para uma análise comportamental da cognição. *Psicologia: Teoria e Pesquisa*, 9(2), 283-303.

Manzano, J. A. N. G., & Oliveira, J. F. de. (2025). *Algoritmos: Lógica para desenvolvimento de programação imperativa de computadores* (30ª ed.). LTC

Skinner, B. F. (1957). *Verbal Behavior*. Appleton-Century-Crofts.

Skinner, B. F. (1969). *Contingencies of Reinforcement: A Theoretical Analysis*. Appleton-Century-Crofts.

Skinner, B. F. (1974). *Sobre o Behaviorismo*. Cultrix.

---

*Este artigo faz parte de uma série que explora conceitos de programação sob a perspectiva da Análise do Comportamento. Acompanhe para mais conteúdos que integram Psicologia Comportamental e Engenharia de Software.*

---

**Tags:** #programação #java #python #estruturasdedados #vetores #strings #funções #recursão #análisedocomportamento #behaviorismoradical #skinner #psicologia #engenhariadesoftware